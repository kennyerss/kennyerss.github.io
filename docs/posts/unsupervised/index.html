<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kent Canonigo">
<meta name="dcterms.date" content="2023-05-03">
<meta name="description" content="This is my implementation of a ML approach for image compression with the singular value decomposition (SVD) as well as the implementation of the Laplacian spectral clustering for a spectral community detection.">

<title>My Awesome CSCI 0451 Blog - Unsupervised Learning with Linear Algebra</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<style>
    .quarto-title-block .quarto-title-banner {
      color: white;
background-image: url(../../img/landscape.png);
background-size: cover;
    }
    </style>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My Awesome CSCI 0451 Blog</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">About Me!</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"><i class="bi bi-twitter" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Unsupervised Learning with Linear Algebra</h1>
                  <div>
        <div class="description">
          This is my implementation of a ML approach for image compression with the singular value decomposition (SVD) as well as the implementation of the Laplacian spectral clustering for a spectral community detection.
        </div>
      </div>
                </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Kent Canonigo </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 3, 2023</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="singular-value-decomposition-svd" class="level1">
<h1>Singular Value Decomposition (SVD)</h1>
<p><a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">Singular value decomposition</a> (SVD) is another form of dimensionality reduction and matrix factorization similar to <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">principal component analysis</a> (PCA) as we’ve explored in previous lectures.</p>
<p>Recall that the SVD of a matrix <span class="math inline">\(A\)</span> is:</p>
<p><span class="math display">\[A = UDV^{T}\]</span></p>
<p>where <span class="math inline">\(U\in\mathbb{R^{mxm}}\)</span> and <span class="math inline">\(V\in\mathbb{R^{nxn}}\)</span> are orthogonal matrices. The <strong>singular values</strong> of <span class="math inline">\(D\in\mathbb{R^{mxn}}\)</span> along its diagonals overall convey some measure of how big <span class="math inline">\(A\)</span> is. By manipulating the singular values of <span class="math inline">\(D\)</span>, we can reconstruct the matrix <span class="math inline">\(A\)</span> from <span class="math inline">\(U\)</span>, <span class="math inline">\(V\)</span>, and <span class="math inline">\(D\)</span>.</p>
<p>Utilizing SVD allows us to make <em>approximations</em> using a smaller representation of the original matrix; in turn, we can use this approximation in applications with images through image compression!</p>
<p>Thus, in this blog post, we’ll make use of SVD to <em>compress</em> images and analyze the effect of varying singular values of <span class="math inline">\(k\)</span> in assessing efficient storage use for large images on computers with minimal storage.</p>
<p>For my RGB image, I’ve chosen a scene from one of my favorite animes, <a href="https://en.wikipedia.org/wiki/One_Piece">One Piece</a>, with Luffy as the main character shown below.</p>
<p><img src="https://media.tenor.com/TaCxCSmzlLEAAAAM/dream-fans-dsmp.gif" class="img-fluid"></p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load_ext autoreload</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>autoreload <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> PIL</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> urllib</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> read_image(url):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(PIL.Image.<span class="bu">open</span>(urllib.request.urlopen(url)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://i.pinimg.com/550x/23/e4/e7/23e4e7aa8e7a9e2dbc75fece9d77fc99.jpg"</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> read_image(url)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>First, I’ll read my image using the <code>read_image</code> function which takes in an image url and converts the image as an np array. In doing so, we can represent the image in its RGB dimensions and convert the image to a greyscale image for SVD image compression.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>fig, axarr <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize <span class="op">=</span> (<span class="dv">7</span>, <span class="dv">3</span>))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> to_greyscale(im):</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">-</span> np.dot(im[...,:<span class="dv">3</span>], [<span class="fl">0.2989</span>, <span class="fl">0.5870</span>, <span class="fl">0.1140</span>])</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>grey_img <span class="op">=</span> to_greyscale(img)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">0</span>].imshow(img)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">0</span>].axis(<span class="st">"off"</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">0</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"original Luffy"</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">1</span>].imshow(grey_img, cmap <span class="op">=</span> <span class="st">"Greys"</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">1</span>].axis(<span class="st">"off"</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">1</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"greyscale Luffy"</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-5-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Now that we’ve converted our image of Luffy to a greyscaled version, we can do compute its SVD to generate a reconstructed image with less storage!</p>
<section id="svd-implementation" class="level2">
<h2 class="anchored" data-anchor-id="svd-implementation">SVD Implementation</h2>
<p>Here is the source code for my implementation of SVD: <a href="https://github.com/kennyerss/kennyerss.github.io/blob/main/posts/unsupervised/svd.py">SVD</a></p>
<p>In my source code, I implemented an <code>SVD</code> class containing two main methods: <code>svd_reconstruct</code> and <code>svd_experiment</code>.</p>
<p>Firstly, I can instantiate an SVD class two arguments to store as its attributes — the image to reconstruct and the number of <code>k</code> components the user wants to use to reconstruct the image. This is defined in the <code>__init__</code> method of the class.</p>
<pre><code>def __init__(self, img, k):
    self.img = img
    self.k = k</code></pre>
<p>Next, I implemented a <code>svd_reconstruct</code> method that again takes in the image to reconstruct, <code>img</code>, and the <code>k</code> components to use. This method returns both the reconstructed image and the total storage needed for the reconstructed image. Shown below is my implementation of the method:</p>
<pre><code>def svd_reconstruct(self, img, k):
    '''
    Input: Image to reconstruct and number of k singular values to use
    Output: Reconstructs image from its singular value decomposition and storage amount
    '''
    # From lecture notes
    U, sigma, V = np.linalg.svd(img)
    
    # Create the D matrix in the SVD
    D = np.zeros_like(img,dtype=float) # matrix of zeros of same shape as img
    # Singular values on the main diagonal
    D[:min(img.shape),:min(img.shape)] = np.diag(sigma)      
    
    # Approximate using the first k columns of U, D, and V
    U_ = U[:, :k]
    D_ = D[:k, :k]
    V_ = V[:k, :]
    
    # Reconstruct our image 
    img_ = U_ @ D_ @ V_

    # Get the dimensions of our img
    m, n = img_.shape

    # Calculate the number of pixels to store for reconstructed image
    storage = ((k*m) + k + (k*n)) / (m*n) * 100

    return img_, round(storage, 1)
    </code></pre>
<p>Most of the code in the <code>svd_reconstruct</code> method were taken from the assignment blog post — specifically reconstructing the image by generating the matrices <code>U</code>, <code>D</code>, and <code>V</code>. In sequential order, I took the first <span class="math inline">\(k\)</span> columns of <span class="math inline">\(U\)</span>, the top <span class="math inline">\(k\)</span> singular values of <span class="math inline">\(D\)</span>, and the first <span class="math inline">\(k\)</span> rows of <span class="math inline">\(V\)</span>. I then computed a matrix multiplication using all three matrices to reconstruct our image <code>img_</code>. Next, I’ll talk about how I calculated the storage needed to represent each reconstructed image.</p>
<section id="amount-of-storage-for-reconstruction" class="level4">
<h4 class="anchored" data-anchor-id="amount-of-storage-for-reconstruction">Amount of Storage for Reconstruction</h4>
<p>To calculate the storage needed for a reconstructed image using some <span class="math inline">\(k\)</span> components, I used the information about how each matrix <span class="math inline">\(U\)</span>, <span class="math inline">\(D\)</span>, and <span class="math inline">\(V\)</span> are “indexed” from the <span class="math inline">\(k\)</span> singular values.</p>
<p>Recall that for the original image, it takes <span class="math inline">\(mn\)</span> total pixels to represent the image, where <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are the dimensions of the image (<span class="math inline">\(m\)</span> rows and <span class="math inline">\(n\)</span> columns). For the matrix <span class="math inline">\(U\)</span>, taking its first <span class="math inline">\(k\)</span> columns will be represented by <span class="math inline">\(km\)</span> total pixels; similarly, taking the first <span class="math inline">\(k\)</span> rows of the matrix <span class="math inline">\(V\)</span> will be represented by <span class="math inline">\(kn\)</span> pixels. To find out the total pixels needed to represent the matrix <span class="math inline">\(D\)</span>, I recognized that the matrix <span class="math inline">\(D\)</span> is a diagonal, square matrix — thus, we can represent and store the matrix using only <span class="math inline">\(k\)</span> pixels even though its dimensions are <span class="math inline">\(k\)</span> by <span class="math inline">\(k\)</span>. Lastly, I divided the total pixels of the reconstructed image by <span class="math inline">\(mn\)</span> pixels, followed by a multiplication of <span class="math inline">\(100\)</span> to get its percentage of storage; I ended up rounding the storage by <span class="math inline">\(1\)</span> decimal point to keep the storage amount interpretable.</p>
<p>This implementation is described in the code below:</p>
<pre><code>storage = ((k*m) + k + (k*n)) / (m*n) * 100</code></pre>
</section>
<section id="reconstructing-an-image" class="level3">
<h3 class="anchored" data-anchor-id="reconstructing-an-image">Reconstructing an Image</h3>
<p>Shown below is a demonstration of using the <code>svd_reconstruct</code> method to reconstruct an image of Luffy.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> svd <span class="im">import</span> SVD</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>SVD_ <span class="op">=</span> SVD(grey_img, k)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># From lecture notes </span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compare_images(A, A_):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    fig, axarr <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize <span class="op">=</span> (<span class="dv">7</span>, <span class="dv">3</span>))</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    axarr[<span class="dv">0</span>].imshow(A, cmap <span class="op">=</span> <span class="st">"Greys"</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    axarr[<span class="dv">0</span>].axis(<span class="st">"off"</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    axarr[<span class="dv">0</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"original image"</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    axarr[<span class="dv">1</span>].imshow(A_, cmap <span class="op">=</span> <span class="st">"Greys"</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    axarr[<span class="dv">1</span>].axis(<span class="st">"off"</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    axarr[<span class="dv">1</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"reconstructed image"</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>img_, storage <span class="op">=</span> SVD_.svd_reconstruct(grey_img, k) <span class="co"># Call function to reconstruct image</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>compare_images(grey_img, img_)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-6-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>For this demonstration, I’ve chosen a <span class="math inline">\(k\)</span> value of <span class="math inline">\(5\)</span>. Here, I’ve plotted both the original and reconstructed image using the <code>compare_images</code> function. Though we’ve successfully reconstructed our original image, it is not indistinguishable by eye that the image <em>is</em> indeed Luffy.</p>
<p>In the next section, we’ll experiment with different <span class="math inline">\(k\)</span> values using the <code>svd_experiment</code> method. Additionally, we’ll observe where the <span class="math inline">\(k\)</span> threshold lies in determining a recognizable reconstructed image of Luffy.</p>
</section>
<section id="experimentation" class="level3">
<h3 class="anchored" data-anchor-id="experimentation">Experimentation</h3>
<p>The other <code>SVD</code> class method I’ve chosen to implement is <code>svd_experiment</code> as shown below.</p>
<pre><code>def svd_experiment(self):
'''
Output: Plots out varied k singular values and its reconstructed images using SVD
'''
# Initialize how many rows and columns we want the subplot axes to have
plt_row = 3
plt_col = 3

fig, axarr = plt.subplots(plt_row, plt_col, figsize = (12,6))

# Plotting each new reconstructed image onto subplot
for i in range(plt_row):
    for j in range(plt_col):
        img_, storage = self.svd_reconstruct(self.img, self.k)

        axarr[i, j].imshow(img_, cmap = "Greys")
        axarr[i, j].axis("off")
        axarr[i, j].set(title = f"{self.k} components, % storage = {storage}")

        # Update k value
        self.k += 5

# Adjust spacing for each subplot
plt.tight_layout()
plt.show()</code></pre>
<p>This method uses the attributes <code>img</code> and <code>k</code> initially instantiated when creating an object of the <code>SVD</code> class. For this experimentation, I’ve chosen to use the same <span class="math inline">\(k\)</span> value of <span class="math inline">\(5\)</span> as with my demonstration of <code>svd_reconstruct</code>. I fixed the dimensions of the axes of my subplots to be <span class="math inline">\(3\)</span> by <span class="math inline">\(3\)</span>, so that I’ll have at least <span class="math inline">\(9\)</span> reconstructed images of Luffy of increasing <span class="math inline">\(k\)</span> components and storage amount. Additionally, I chose to increase value of <span class="math inline">\(k\)</span> by <span class="math inline">\(5\)</span> after each iteration of my nested for loop.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform experiment</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>SVD_ <span class="op">=</span> SVD(grey_img, k <span class="op">=</span> <span class="dv">5</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>SVD_.svd_experiment()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-7-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>From my experiment, I plotted several reconstructed images of Luffy up to <span class="math inline">\(45\)</span> components starting at <span class="math inline">\(5\)</span> components. By observation, the reconstructed image becomes indistinguishable to the original greyscaled image around <span class="math inline">\(30\)</span> components. For the reconstructed image of <span class="math inline">\(30\)</span> components, we only needed to store around <span class="math inline">\(14.0\)</span>% of the original storage amount. Hence, we’ve successfully compressed our original image to reduce the storage amount by <span class="math inline">\(86.0\)</span>%!</p>
</section>
</section>
</section>
<section id="spectral-community-detection" class="level1">
<h1>Spectral Community Detection</h1>
<p>In this second half of the blog post, I’ll be implementing the Laplacian spectral clustering algorithm as a method for finding interesting clusters in point cloud data sets by operating on a graph. Well, which graph? The <strong>KARATE CLUB GRAPH</strong>!</p>
<p><img src="https://media2.giphy.com/media/PudZiAbQDUEik/giphy.gif" class="img-fluid"></p>
<p>The karate club graph is a graph representing a social network whose nodes represents an individual member of a karate club. Shown below, I’ve generated a karate club graph <span class="math inline">\(G\)</span> using the <code>networkx</code> package; the blue nodes represent the <code>Mr. Hi</code> club, and the orange nodes represent the <code>Officer</code> club.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">12345</span>) <span class="co"># For reproducibility</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># From lecture notes to generate karate club graph</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.karate_club_graph()</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>layout <span class="op">=</span> nx.layout.fruchterman_reingold_layout(G)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>clubs <span class="op">=</span> nx.get_node_attributes(G, <span class="st">"club"</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>fig, axarr <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="dv">5</span>,<span class="dv">5</span>))</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G, layout,</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        with_labels<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        node_color <span class="op">=</span> [<span class="st">"orange"</span> <span class="cf">if</span> clubs[i] <span class="op">==</span> <span class="st">"Officer"</span> <span class="cf">else</span> <span class="st">"steelblue"</span> <span class="cf">for</span> i <span class="kw">in</span> G.nodes()],</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        edgecolors <span class="op">=</span> <span class="st">"black"</span>, <span class="co"># confusingly, this is the color of node borders, not of edges</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axarr) </span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>axarr.<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"original clustering"</span>)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-8-output-1.png" class="img-fluid"></p>
</div>
</div>
<section id="laplacian-spectral-clustering-implementation" class="level2">
<h2 class="anchored" data-anchor-id="laplacian-spectral-clustering-implementation">Laplacian Spectral Clustering Implementation</h2>
<p>To implement the Laplacian spectral clustering, recall in the lecture notes that the equation for the normalized random walk Laplacian is:</p>
<p><span class="math display">\[ L = D^{-1}[D-A] \]</span></p>
<p>Here, the matrix <span class="math inline">\(D\)</span> is the degree matrix obtained from the adjacency matrix <span class="math inline">\(A\)</span>.</p>
<p><span class="math display">\[D = [\sum_{j=1}^{n} A_{i,j}]\]</span></p>
<p>We then use the normalized Laplacian matrix <span class="math inline">\(L\)</span> to choose some estimate <span class="math inline">\(z\)</span> to minimize the normcut that will split the karate club graph into binary labels corresponding to each node’s club. From the lecture notes, we can find this estimated <span class="math inline">\(z\)</span> as the eigenvector of the normalized Laplacian matrix with the second-smallest eigenvalue.</p>
<p>In my implementation of the <code>spectral_clustering</code> function, I first extracted and symmetrized the adjacency matrix, <span class="math inline">\(A\)</span>, from my karate club graph <span class="math inline">\(G\)</span>. I then used this adjacency matrix to generate the degree matrix <span class="math inline">\(D\)</span> by taking the sum of <span class="math inline">\(A\)</span>’s rows as its diagonal entries.</p>
<p>Then, we can find the inverse of <span class="math inline">\(D\)</span> using the <code>numpy</code> operation<code>np.linalg.inv()</code> and calculate the normalized Laplacian matrix <span class="math inline">\(L\)</span> by doing a matrix multiplication between <span class="math inline">\(D^{-1}\)</span> and <span class="math inline">\(D - A\)</span>.</p>
<p>I then found the eigenvalues and eigenvectors of <span class="math inline">\(L\)</span> using the numpy operation <code>np.linalg.eig()</code>. Since we want to choose the eigenvector corresponding to the second-smallest eigenvalue of <span class="math inline">\(L\)</span>, I first sorted the eigenvalues by sorted indices in ascending order using the numpy operation <code>np.argsort</code>. Rather than sorting the eigenvalues by its values, I sorted them by indices to easily extract where the index of second-smallest eigenvalue will be.</p>
<p>Lastly, I indexed the eigenvectors of <span class="math inline">\(L\)</span> up to the second-smallest index of the sorted indices in <code>sorted_eig</code>, which would just be at the <span class="math inline">\(1\)</span>th index — finally, we’ve found our estimated cluster vector <span class="math inline">\(z\)</span>!</p>
<p>We can retrieve the final set of cluster labels by transforming <span class="math inline">\(z\)</span> as a vector of binary labels. This is done through the line of code: <code>1*(z_ &gt; 0)</code> — which is just an implementation of the indicator function!</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> spectral_clustering(G):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Input: Graph G</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Output: Vector of binary labels to split graph</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract adjacency matrix from graph G</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> nx.adjacency_matrix(G).toarray()</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Symmetrize the matrix </span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> A <span class="op">+</span> A.T</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    A[A <span class="op">&gt;</span> <span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># D is the degree matrix obtained from the adjacency matrix</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    D <span class="op">=</span> np.diag(A.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate the normalized Laplacian matrix</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> np.linalg.inv(D) <span class="op">@</span> (D<span class="op">-</span>A)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Using np.linalg.eig to return eigenvalues and eigenvectors in ascending order</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    eig_val, eig_vec <span class="op">=</span> np.linalg.eig(L)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort eigenvalues in order to find index of the second smallest eigenvalue</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    sorted_eig <span class="op">=</span> np.argsort(eig_val)</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    z_ <span class="op">=</span> eig_vec[:, sorted_eig[<span class="dv">1</span>]] <span class="co"># Obtain the eigenvector with second smallest eigenvalue of L</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> <span class="dv">1</span><span class="op">*</span>(z_ <span class="op">&gt;</span> <span class="dv">0</span>) <span class="co"># Transform into binary labels</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> z</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="plotting-the-spectral-cluster" class="level3">
<h3 class="anchored" data-anchor-id="plotting-the-spectral-cluster">Plotting the Spectral Cluster</h3>
<p>After implementing the Laplacian spectral clustering algorithm, we can now plot the set of spectral labels to determine how well its classified each node of the karate club graph.</p>
<p>Recall that for the binary cluster labels, <span class="math inline">\(0\)</span> represents the <code>Mr. Hi</code> club, and a <span class="math inline">\(1\)</span> would represent the <code>Officer</code> club.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate our cluster labels</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 0: "Mr. Hi", 1: "Officer"</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>cluster_labels <span class="op">=</span> spectral_clustering(G)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting each graph side by side</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>fig, axarr <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize <span class="op">=</span> (<span class="dv">13</span>,<span class="dv">6</span>))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Original graph</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G, layout,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        with_labels<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        node_color <span class="op">=</span> [<span class="st">"orange"</span> <span class="cf">if</span> clubs[i] <span class="op">==</span> <span class="st">"Officer"</span> <span class="cf">else</span> <span class="st">"steelblue"</span> <span class="cf">for</span> i <span class="kw">in</span> G.nodes()],</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        edgecolors <span class="op">=</span> <span class="st">"black"</span>,</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axarr[<span class="dv">0</span>]) </span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Spectral graph with random walk normalized Laplacian</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>nx.draw_networkx(G, layout,</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        with_labels<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        node_color <span class="op">=</span> [<span class="st">"orange"</span> <span class="cf">if</span> i <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="st">"steelblue"</span> <span class="cf">for</span> i <span class="kw">in</span> cluster_labels],</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        edgecolors <span class="op">=</span> <span class="st">"black"</span>,</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axarr[<span class="dv">1</span>]) </span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Set graph titles </span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">0</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"original clustering"</span>)</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>axarr[<span class="dv">1</span>].<span class="bu">set</span>(title <span class="op">=</span> <span class="st">"random walk normalized Laplacian spectral clustering"</span>)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-11-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>After plotting both the original clustering and the random walk normalized Laplacian spectral clustering of our graph <span class="math inline">\(G\)</span>, we observed that our spectral clustering does significantly well in dividing the graph into similar clusters as found by the original clustering. Only two nodes out of 34, the <span class="math inline">\(8th\)</span> and <span class="math inline">\(2nd\)</span> nodes, were misclassified as part of the <code>Officer</code> club by the spectral clustering algorithm. Thus, the algorithm’s misclassification rate in divding the graph into each respective club is only about <span class="math inline">\(6\)</span>% — pretty good!</p>
<p>Since the two nodes are right in the middle of the graph, it would be reasonable that our algorithm is unable to correctly classify the two nodes’ clubs.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>